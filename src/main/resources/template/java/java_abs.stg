class(name,type, members,interfaces,functions) ::= <<

package makefsm;
import java.util.concurrent.ConcurrentLinkedQueue;

public abstract class <name> {

   //状态机的名字
   String fsmName = "<name>";

   // 状态机实例 uuid
   String fsmInstanceId = "<name>".trim()+"_"+UUID.randomUUID().toString();

   //状态机类型
   String fsmType = "<type>";

   //当前状态
   private States __Y;
   private boolean __exitFlag = false;

   //最后一次正确输入状态


   //输入队列
   private ConcurrentLinkedQueue\<Event> __inputEvents = new ConcurrentLinkedQueue\<Event>();

   //输出队列
   private ConcurrentLinkedQueue\<Event> __outputEvents = new ConcurrentLinkedQueue\<Event>();

   //异常队列
   private ConcurrentLinkedQueue\<Event> __errorEvents = new ConcurrentLinkedQueue\<Event>();

    //状态和事件的枚举变量
   <members ; separator="\n">

   //输入列表,状态机的输入，体现为事件。
   //输出列表,是状态机的一个响应输出，如果是moore状态机 则和 当前状态有关。 如果是mealy 状态机 则和当前输入和当前状态有关。 在这里实现为， moore 是事件触发，状态迁移完成时触发。 mealy 状态机 则是在事件触发后， 状态为迁移前触发。
   //每一个状态机还维护一个最后的输出状态，该状态包含了时间,输入，和迁移前状态。
   //迁移函数，直接体现在事件响应中。
   //状态迁移过程:
   //   1. 判断输入是否是当前状态允许接受的输入。 如果不是，则触发 未预期警告
   //   2. 迁移前状态检查。
   //   3. 迁移时动作响应内容，不成功则执行回滚函数。
   //   4. 迁移前状态检查。
   //   5. 发射输出

   // 关于错误处理, 对于未受控的行为将都会发布到 异常队列里面， 由应用具体去判断，
   //  包括
   //   1. 当前状态下的非法输入序列。
   //   2. 状态迁移前检查异常，无法迁移
   //   3. 状态迁移中动作异常，无法迁移
   //   4. 状态迁移后检查异常，已经迁移
   //   5. 其他异常

   <interfaces; separator="\n">

   //主要实现的函数
   <functions; separator="\n">

   public void exit(States state) {

      __exitFlag = true;

      System.out.println(" exit from state["+state.toString()+"]");

   }


   public void emitEvent(Event e)
   {
     //往队列中添加事件
     synchronized (__events) {
       __events.add(e);
       if (__events.size()==1) __events.notify();

  }

    }
}
>>


constants(typename, names) ::= <<
public enum <typename> {
    <names; separator=",\n">
    } ;
>>

enteractions(name) ::=<<
   protected abstract void enter<name>();
>>

onevent(name) ::=<<
   protected abstract void  on<name>(Event e);
>>

begin(beginState) ::= <<
   public void begin()
   {
     __Y = States.<beginState>;

     while(!__exitFlag){
       Event  e = null;
       synchronized (__events) {
         e = __events.poll();
         if(e==null)
         {
           try {
          __events.wait();
           } catch (InterruptedException e1) {
             e1.printStackTrace();
           }
           continue;
         }
    }
       __processEvent(e);
     }
     }
>>


processevent(caseblock) ::= <<

void __processEvent( Event e ){
		   switch( __Y ) {
		   <caseblock; separator="\n">
		   }
    }
>>


case(statusName,ifblock) ::= <<case <statusName>:
      <if(ifblock)><ifblock ; separator=" else "><endif>
      break;
>>


//如果目标状态是终结状态，则还需要可以调用退出函数
event_if(eventName,newStatusName,funName,isMooreType,isEndState) ::= <<if( e == Event.<eventName> ) {
         <if(isMooreType)>
         __Y = States.<newStatusName>;
         enter<funName>();
         <else>
         on<funName>(e);
         __Y = States.<newStatusName>;<endif>
         <if(isEndState)>exit(__Y);<endif>
      }
>>

unexpect_event(isStrict) ::= <<
      {
         <if(isStrict)>

         if(ture) throw new Exception("inputEvent["+e.toString()+"] is unexpecting");

         <else>

         skipUnexpectEvent(e);

         <endif>
      }
>>

unexpect_event_handle(isStrict) ::= <<

         <if(isStrict)>

         private void skipUnexpectEvent(Event e) {

         System.out.println("Event["+e.toString()+"] is skipping");

         }
         <endif>

>>






